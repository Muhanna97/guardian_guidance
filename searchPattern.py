% SearchPatternGenerator% RichardArthurs% Mayimport math# p1(start) p4# p2 p3(end)def m2geo(metres):    return (metres/11.1)*0.0001; # convert meters to decimal degrees https://gis.stackexchange.com/questions/8650/measuring-accuracy-of-latitude-and-longitudedef geo2m(geo):    return (geo / 0.0001) * 11.1; #convert decimal degrees to metersdef haversine_a(lat1,long1,lat2,long2):    return math.sin(abs(lat2 - lat1) / 2) ^ 2 + math.cos(lat1) * math.cos(lat2) * math.sin(abs(long2 - long1) / 2) ^ 2def haversine(lat1,long1,lat2,long2):    # % output = km, input = RADIANS    return (2 * atan2(sqrt(haversine_a(lat1, long1, lat2, long2)), sqrt(1 - haversine_a(lat1, long1, lat2, long2)))) * 6378.137# search area coordslat = y, long = xp1x = -122.7963030p1y = 49.1294287p2x = -122.7963138p2y = 49.1285792p3x = -122.7907777p3y = 49.1285230p4x = -122.7906597p4y = 49.1295129x = [p1x, p2x, p3x, p4x]y = [p1y, p2y, p3y, p4y]# p1 and p2 are oriented north/south of EO, as are p3, p4# determine number of passes# to ensure the track width is held, at a minimum. Less efficient but gives 100% coveragetrackWidth = 20 # distance between passes(metres)numSteps = max(abs((p2y - p1y) / m2geo(trackWidth)), abs((p4y - p3y) / m2geo(trackWidth)))numSteps = round(numSteps) #next highest integerwestStep = abs((p2y - p1y) / numSteps) #step size in geo unitseastStep = abs((p4y - p3y) / numSteps)direction = -1 # -1 = flying SOUTH - not fully implementedfor i in range(numSteps):    angWest = atan((p2y - p1y) / (p2x - p1x))    westSide(i, 1) = -westStep * i * math.cos(angWest) - abs(p1x) # referenced to p1x so need to offset by it    westSide(i, 2) = direction * westStep * i * math.sin(angWest) + p1y    angEast = atan((p4y - p3y) / (p4x - p3x))    eastSide(i, 1) = eastStep * i * math.cos(angEast) - abs(p3x)    eastSide(i, 2) = -direction * eastStep * i * math.sin(angEast) + p3yeastSide = flipud(eastSide) # flip east side so east-west pairs are collatedwestSide = vertcat([p1x,p1y],westSide) # include p1 (origin in the list of west side points)eastSide = vertcat(eastSide,[p3x,p3y]) # include p3 (origin in the list of east side points)# Generate wp list in sequential ordernumPts = numSteps + 1eastIndex = 1westIndex = 2num = 0# slightly awkward way to orient the waypoints in the correct orderfor i = 1:numPts * 2 - 2:    if num == 0 | | num == 1: # two east and then two west        final(i,:) = eastSide(eastIndex,:)        eastIndex = eastIndex + 1        num = num + 1    else:        final(i,:) = westSide(westIndex,:)        westIndex = westIndex + 1        num = num + 1    if num == 4:        num = 0final = vertcat([p1x,p1y],final) # insert the first wp at the topfinal = vertcat(final,[p3x,p3y]) # insert last wp at the bottom# % print out# the# waypoints in flying# order# for i = 1:length(final)# plot(final(i, 1), final(i, 2), 'r--o')# pause(.1)# end#Calculate Straight Line Distance using haversine formula between each waypointfor i = 1:length(final) - 1    distance(i) = haversine(deg2rad(final(i, 2)), deg2rad(final(i, 1)), deg2rad(final(i + 1, 2)), deg2rad(final(i + 1, 1)))fprintf('Total distance: %f km\r\n', sum(distance))
# % Search# Pattern# Generator# % Richard# Arthurs# % Mayimport math# p1(start) p4# p2 p3(end)def m2geo(metres):    return (metres/11.1)*0.0001; # convert meters to decimal degrees https://gis.stackexchange.com/questions/8650/measuring-accuracy-of-latitude-and-longitudedef geo2m(geo):    return (geo / 0.0001) * 11.1; #convert decimal degrees to metersdef haversine_a(lat1,long1,lat2,long2):    return math.sin(abs(lat2 - lat1) / 2) ^ 2 + math.cos(lat1) * math.cos(lat2) * math.sin(abs(long2 - long1) / 2) ^ 2def haversine(lat1,long1,lat2,long2):    # % output = km, input = RADIANS    return (2 * math.atan2(math.sqrt(haversine_a(lat1, long1, lat2, long2)), math.sqrt(1 - haversine_a(lat1, long1, lat2, long2)))) * 6378.137# search area coords# lat = y, long = xp1x = -122.7963030p1y = 49.1294287p2x = -122.7963138p2y = 49.1285792p3x = -122.7907777p3y = 49.1285230p4x = -122.7906597p4y = 49.1295129x = [p1x, p2x, p3x, p4x]y = [p1y, p2y, p3y, p4y]# p1 and p2 are oriented north/south of EO, as are p3, p4# determine number of passes# to ensure the track width is held, at a minimum. Less efficient but gives 100% coveragetrackWidth = 20 # distance between passes(metres)numSteps = max(math.fabs((p2y - p1y) / m2geo(trackWidth)), math.fabs((p4y - p3y) / m2geo(trackWidth)))numSteps = round(numSteps) #next highest integerprint numStepswestStep = math.fabs((p2y - p1y) / numSteps) #step size in geo unitseastStep = math.fabs((p4y - p3y) / numSteps)print "west step:", westStepprint "east step:", eastStepdirection = -1 # -1 = flying SOUTH - not fully implementedwestSide_lat = []westSide_lon = []eastSide_lat = []eastSide_lon = []lat = []lon = []for i in range(int(numSteps)):    angWest = math.atan((p2y - p1y) / (p2x - p1x))    westSide_lon.append(-westStep * i * math.cos(angWest) - abs(p1x))  # referenced to p1x so need to offset by it    westSide_lat.append(direction * westStep * i * math.sin(angWest) + p1y)    angEast = math.atan((p4y - p3y) / (p4x - p3x))    eastSide_lon.append(eastStep * i * math.cos(angEast) - abs(p3x))    eastSide_lat.append(-direction * eastStep * i * math.sin(angEast) + p3y)## print "west lat", westSide_lat# print "west lon", westSide_lon# print "east lat", eastSide_lat# print "east lon", eastSide_lonfor j in range(len(westSide_lon)):    lat.append(eastSide_lat[j])    lon.append(eastSide_lon[j])    lat.append(westSide_lat[j])    lon.append(westSide_lon[j])print latprint lon# eastSide = flipud(eastSide) # flip east side so east-west pairs are collated# westSide = vertcat([p1x,p1y],westSide) # include p1 (origin in the list of west side points)# eastSide = vertcat(eastSide,[p3x,p3y]) # include p3 (origin in the list of east side points)## # Generate wp list in sequential order# numPts = numSteps + 1# eastIndex = 1# westIndex = 2# num = 0## # slightly awkward way to orient the waypoints in the correct order# for i = 1:numPts * 2 - 2:#     if num == 0 | | num == 1: # two east and then two west#         final(i,:) = eastSide(eastIndex,:)#         eastIndex = eastIndex + 1#         num = num + 1#     else:#         final(i,:) = westSide(westIndex,:)#         westIndex = westIndex + 1#         num = num + 1##     if num == 4:#         num = 0#### final = vertcat([p1x,p1y],final) # insert the first wp at the top# final = vertcat(final,[p3x,p3y]) # insert last wp at the bottom# % print out# the# waypoints in flying# order# for i = 1:length(final)# plot(final(i, 1), final(i, 2), 'r--o')# pause(.1)# end## #Calculate Straight Line Distance using haversine formula between each waypoint# for i = 1:length(final) - 1#     distance(i) = haversine(deg2rad(final(i, 2)), deg2rad(final(i, 1)), deg2rad(final(i + 1, 2)), deg2rad(final(i + 1, 1)))## fprintf('Total distance: %f km\r\n', sum(distance))